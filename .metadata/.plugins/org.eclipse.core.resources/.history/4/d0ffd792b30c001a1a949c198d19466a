package cr.ac.tec.graph.api.util;

import cr.ac.tec.graph.api.dto.Graph;
import cr.ac.tec.graph.api.dto.ObjectDijkstra;

public class Dijkstra {
	
	//metodo para derminar xaminos segun el algoritmo de floyd
    public static String RutaCorta( long [][] mAdy, int start, int end){

        int vertices = mAdy.length;
        long matrizAdyacencia [][] = mAdy;
        String caminos [][] = new String [vertices][vertices];
        String caminosAuxiliares [][]=new String [vertices][vertices];
        String caminoRecorrido ="",cadena="",caminitos="";
        int i,j,k;
        float temporal1, temporal2, temporal3, temporal4, minimo;
        //inicializar matrices y caminos
        for(i=0;i<vertices;i++) {
            for(j=0;j<vertices;j++){
                caminos[i][j]="";
                caminosAuxiliares[i][j]="";
            }
        }

        for(k=0;k<vertices; k++){
            for(i=0;i<vertices; i++){
                for (j=0;j<vertices; j++){

                    temporal1=matrizAdyacencia [i][j];
                    temporal2=matrizAdyacencia [i][k];
                    temporal3=matrizAdyacencia [k][j];
                    temporal4= temporal2 + temporal3;
                    //encontrando al minimo
                    minimo=Math.min(temporal1, temporal4);
                    if(temporal1!=temporal4){
                        if(minimo == temporal4){
                            caminoRecorrido="";
                            caminosAuxiliares[1][j] = k + "";
                            caminos[i][j]= caminosR(i,k,caminosAuxiliares, caminoRecorrido) + (k+1);

                        }
                    }
                    matrizAdyacencia[i][j]=(long) minimo;
                }
            }
        }
        ObjectDijkstra d = new ObjectDijkstra();
        for(i=0;i<vertices;i++) {
            for(j=0;j<vertices;j++){
                if(matrizAdyacencia[i][j]!=1000000000){
                    if(i!=j && i == start && end == j){
                        if(caminos[i][j].equals("")){
                            caminitos += "de ("+ (i)+"---->"+(j)+") irse por...("+(i)+", "+(j)+")   peso: " + matrizAdyacencia[i][j] + "\n";
                        }else{ caminitos +="de ("+ (i)+"---->"+(j)+") irse por...("+(i)+", "+caminos[i][j] + ", " +(j)+")   peso: " + matrizAdyacencia[i][j]  + "\n";
                        }
                        d.setValorCamino((int)matrizAdyacencia[i][j]);
                        
                    }
                }
            }
        }
        
        

        return caminitos;
    }
    public static String caminosR(int i, int k, String[][] static class Graph{
        int vertices;
        int matrix[][];

        public Graph(int vertex) {
            this.vertices = vertex;
            matrix = new int[vertex][vertex];
        }

        public void addEdge(int source, int destination, int weight) {
            //add edge
            matrix[source][destination]=weight;

            //add back edge for undirected graph
            matrix[destination][source] = weight;
        }

        //get the vertex with minimum distance which is not included in SPT
        int getMinimumVertex(boolean [] mst, int [] key){
            int minKey = Integer.MAX_VALUE;
            int vertex = -1;
            for (int i = 0; i <vertices ; i++) {
                if(mst[i]==false && minKey>key[i]){
                    minKey = key[i];
                    vertex = i;
                }
            }
            return vertex;
        }

        public void dijkstra_GetMinDistances(int sourceVertex){
            boolean[] spt = new boolean[vertices];
            int [] distance = new int[vertices];
            int INFINITY = Integer.MAX_VALUE;

            //Initialize all the distance to infinity
            for (int i = 0; i <vertices ; i++) {
                distance[i] = INFINITY;
            }

            //start from the vertex 0
            distance[sourceVertex] = 0;

            //create SPT
            for (int i = 0; i <vertices ; i++) {

                //get the vertex with the minimum distance
                int vertex_U = getMinimumVertex(spt, distance);

                //include this vertex in SPT
                spt[vertex_U] = true;

                //iterate through all the adjacent vertices of above vertex and update the keys
                for (int vertex_V = 0; vertex_V <vertices ; vertex_V++) {
                    //check of the edge between vertex_U and vertex_V
                    if(matrix[vertex_U][vertex_V]>0){
                        //check if this vertex 'vertex_V' already in spt and
                        // if distance[vertex_V]!=Infinity

                        if(spt[vertex_V]==false && matrix[vertex_U][vertex_V]!=INFINITY){
                            //check if distance needs an update or not
                            //means check total weight from source to vertex_V is less than
                            //the current distance value, if yes then update the distance

                            int newKey =  matrix[vertex_U][vertex_V] + distance[vertex_U];
                            if(newKey<distance[vertex_V])
                                distance[vertex_V] = newKey;
                        }
                    }
                }
            }
            //print shortest path tree
            printDijkstra(sourceVertex, distance);
        }

        public void printDijkstra(int sourceVertex, int [] key){
            System.out.println("Dijkstra Algorithm: (Adjacency Matrix)");
            for (int i = 0; i <vertices ; i++) {
                System.out.println("Source Vertex: " + sourceVertex + " to vertex " +   + i +
                        " distance: " + key[i]);
            }
        }
    }

    public static void main(String[] args) {
        int vertices = 6;
        Graph graph = new Graph(vertices);
        int sourceVertex = 0;
        graph.addEdge(0, 1, 4);
        graph.addEdge(0, 2, 3);
        graph.addEdge(1, 2, 1);
        graph.addEdge(1, 3, 2);
        graph.addEdge(2, 3, 4);
        graph.addEdge(3, 4, 2);
        graph.addEdge(4, 5, 6);
        graph.dijkstra_GetMinDistances(sourceVertex);
    }, String caminoRecorrido) {
        if(caminosAuxiliares[i][k].equals("")){
            return "";
        }else{
            caminoRecorrido +=caminosR(i, Integer.parseInt(caminosAuxiliares[i][k].toString()), caminosAuxiliares, caminoRecorrido)+(Integer.parseInt(caminosAuxiliares[i][k].toString())+1)+", ";
            return caminoRecorrido;
        }
    }
	
	
}
